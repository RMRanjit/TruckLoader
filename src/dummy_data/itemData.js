import { packageData } from "./packageData";
import { truckConfig } from "./truckConfig";
import { v4 as uuidv4 } from 'uuid';
import { CompressedPixelFormat } from "three";

// Logic to fill in bays based on the packageData
// Read the position of first bay from truckConfig
// Calculate the volume of the bay ( height * width * Length ) based on the bayHeight, bayWidth, bayLength
// check if the next package can fit in the selected bay ( volume of the package is based of Height, Width, Length )
// if the package can fit in the selected bay, then increment the height, width, Length of the bay
// if the package can't fit in the selected bay,  then increment the bay number and start again

const pacakageScaleMultiplier = 0.05;
const packageBuffer = 0.05;



// Note: this function is being called twice from App.js
// put in a workaround, to identify  the package using the packageIdentifier generated by npm package uuid

export function getLoadData(caller)
{
  console.log("Called by " + caller);
  let items = [];
  let currentBayIndex = 0
  let bayConfig = truckConfig[currentBayIndex];
  let bayRemainingVolume = bayConfig.bayHeight * bayConfig.bayWidth * bayConfig.bayLength ;
  let currentBayX = bayConfig.bayPosition[0] + (bayConfig.bayLength / 2) - packageBuffer;
  let currentBayY = bayConfig.bayPosition[1] - (bayConfig.bayHeight / 2) + packageBuffer; 
  let currentBayZ = bayConfig.bayPosition[2]- (bayConfig.bayWidth / 2)  + packageBuffer;
  let bayRemainingLength  = bayConfig.bayLength - packageBuffer
  



  // Intent: get the package data and create an item for each package
  for(let orderIndex = 0; orderIndex < packageData.length; orderIndex++)
  {
    let order = packageData[orderIndex];
    

    // get the items under the current order
    for(let orderItemIndex = 0; orderItemIndex < order.items.length; orderItemIndex++)
    { 
      console.log("Order item %d-%d is loaded on Bay %s with positions [%d,%d,%d]",order.orderNumber,orderItemIndex, bayConfig.bayName,currentBayX,currentBayY,currentBayZ)
      let orderItem = order.items[orderItemIndex];
      // Normalize the package dimensions to the bay dimensions by multiplying the scale factor
      let packageHeight = orderItem.height * pacakageScaleMultiplier;
      let packageWidth = orderItem.width * pacakageScaleMultiplier;
      let packageLength = orderItem.length * pacakageScaleMultiplier;

    
      // Initiatize the item to be added
      let item = {
            packageIdentifier : uuidv4(),
            bayName: bayConfig.bayName,
            packageBayPosition: bayConfig.bayName,
            orderNumber: order.orderNumber.toString().padStart(4, "0"),
            itemNumber: orderIndex.toString().padStart(5, "0"),
            productName: orderItem.productName,
            productImage: orderItem.productImage,
            height: packageHeight,
            length: packageLength,
            width: packageWidth,
            weightInLbs: orderItem.weightInLbs,
            packageColor : orderItem.productColor,
            docked : true,
            position: [
              currentBayX - packageLength / 2,
              currentBayY + packageHeight / 2,
              currentBayZ + packageWidth / 2
            ],
          }

          items = [...items, item];


          // We are loading by X axis.. so increment it
          //if(bayConfig.bayLength < (currentBayX+ item.length + packageBuffer) )
          if(bayRemainingLength > 0 )
          {
            currentBayX -= item.length + packageBuffer;
            bayRemainingLength -= item.length + packageBuffer
          }
          else
          {
            currentBayZ += item.width + packageBuffer 
            currentBayX = bayConfig.bayPosition[0] + (bayConfig.bayLength / 2) - packageBuffer ;
            bayRemainingLength = bayConfig.bayLength
          }

    }

  }

console.log("Finally Completed with items %d", items.length)
return items;
}


// for ( let bayNumber = 0; bayNumber < truckConfig.length; bayNumber++ ) {


//     let bayConfig = truckConfig[bayNumber];
//     let bayRemainingVolume = bayConfig.bayHeight * bayConfig.bayWidth * bayConfig.bayLength ;
//     let currentBayX = bayConfig.bayPosition[0] + (bayConfig.bayLength / 2) - packageBuffer ;
//     let currentBayY = bayConfig.bayPosition[1] - (bayConfig.bayHeight / 2) + packageBuffer; 
//     let currentBayZ = bayConfig.bayPosition[2]- (bayConfig.bayWidth / 2)  + packageBuffer;
//     let currentBayLength = 0.05; // give some buffer space with the wall of the bay
//     let currentBayWidth = 0.05; // give some buffer space with the wall of the bay
//     let currentBayHeight = 0.05; // give some buffer space with the wall of the bay

//     // console.log("Rendering bay: " + bayName + " with volume: " + bayVolume);

//     for ( let orderIndex = _orderIndex; orderIndex < packageData.length; orderIndex++ ) {

//         let order = packageData[orderIndex];
//         // console.log("Order %s has %d items", order.orderNumber, order.items.length)

//         // Loop through the items in the order
//         for ( let orderItem = _orderItem; orderItem < order.items.length; orderItem++)
//         {
//           let orderItemVolume = (order.items[orderItem].height * order.items[orderItem].width * order.items[orderItem].length) * Math.pow(pacakageScaleMultiplier,3) ;
//           let itemLength = order.items[orderItem].length * pacakageScaleMultiplier;

//         // // Lets start setting the order item length wise i.e X-co-ordinate
//         // // if the order item length exceed the bay width, then load it in width wise - z-co-ordinate
//         // // if the stack is complete ( all order items are loaded width wise, increment  the height wise - y-co-ordinate )
//         console.log("Checking if the bay %s (L - %d) can accomodate the item %s-%s (L - %d) with occupied length of %d ",bayConfig.bayName,bayConfig.bayLength, order.orderNumber.toString().padStart(4, "0"), orderItem.toString().padStart(5, "0"), order.items[orderItem].length*pacakageScaleMultiplier, currentBayLength);

//         if (bayConfig.bayLength > (currentBayLength + itemLength + packageBuffer )) {
//           console.log("Package loaded length wise at length %d", currentBayX)
//           currentBayX -= (itemLength + packageBuffer); ;
//           currentBayLength += itemLength + packageBuffer}
//         else{
//           //reset the x-co-ordinate to the start of the bay
//           console.log("Resetting the length wise x-co-ordinate to the start of the bay %s %d - %d", bayConfig.bayName,bayConfig.bayLength, currentBayX);
//           currentBayX = bayConfig.bayPosition[0] + (bayConfig.bayLength / 2) - packageBuffer ;}
//         // currentBayLength = 0.05 // give some buffer space with the wall of the bay
//         // currentBayZ += .5//order.items[orderItem].width // increment the width
//         //currentBayY -= order.items[orderItem].height * pacakageScaleMultiplier;
//         //currentBayZ -= order.items[orderItem].width * pacakageScaleMultiplier;


//           // console.log("Order item %s has volume:", order.orderNumber+ "-" + orderItem, orderItemVolume);
//         if ( orderItemVolume <= bayRemainingVolume ) {
         
//             let item = {
//             packageIdentifier : uuidv4(),
//             bayName: bayConfig.bayName,
//             packageBayPosition: bayConfig.bayName,
//             orderNumber: order.orderNumber.toString().padStart(4, "0"),
//             itemNumber: orderIndex.toString().padStart(5, "0"),
//             productName: order.items[orderItem].productName,
//             productImage: order.items[orderItem].productImage,
//             height: order.items[orderItem].height * pacakageScaleMultiplier,
//             length: order.items[orderItem].length * pacakageScaleMultiplier,
//             width: order.items[orderItem].width * pacakageScaleMultiplier,
//             weightInLbs: order.items[orderItem].weightInLbs,
//             docked : true,
//             position: [
//               currentBayX,
//               currentBayY,
//               currentBayZ
//             ],

//           }
//         items = [...items, item];
//         bayRemainingVolume -= orderItemVolume;
//         _orderIndex = orderIndex;

        
//         //console.log("Addded order " + order.orderNumber + "-" + orderItem + " to bay " + bayConfig.bayName + " with remaining volume: " + bayRemainingVolume);

//         } else {

//           // if the bay is full ( indicated by the remaining valume < Order Item volume)
//           // then increment the bay number and start again
//           // reset the remaining volume to the volume of the bay
//           // we dont want to miss the order item, so set it to the current order item
//           // reset the current bay x, y, z to the position of the new bay
//           console.log("bay full");
//             bayNumber++;
//             bayConfig = truckConfig[bayNumber];
//             bayRemainingVolume = bayConfig.bayHeight * bayConfig.bayWidth * bayConfig.bayLength;;
//             orderItem--;
//             currentBayX = bayConfig.bayPosition[0] + (bayConfig.bayLength / 2) - packageBuffer ;
//             currentBayY = bayConfig.bayPosition[1] - (bayConfig.bayHeight / 2) + packageBuffer; 
//             currentBayZ = bayConfig.bayPosition[2]- (bayConfig.bayWidth / 2)  + packageBuffer;


//             currentBayLength = 0.5; // give some buffer space with the wall of the bay
//             currentBayWidth = 0.5; // give some buffer space with the wall of the bay
//             currentBayHeight = 0.5; // give some buffer space with the wall of the bay
//         }
//       }
//     }



// const LoadStartX =10;
// const LoadStartY = -1;
// const LoadStartZ = 8;
// const frameIncrements = -2;
// const maxItemsInRow = 8;
// const maxItemsInSide = maxItemsInRow * 4;


// export function getItems() {

//   let items = [];

//   let LoadXIncrement = LoadStartX;
//   let LoadYIncrement = LoadStartY;
//   let LoadZIncrement = LoadStartZ;

//   for (let order = 0; order < packageData.length; order++) {
//     let itemCount = packageData[order].items.length;
//     for (let itemIterator = 0; itemIterator < packageData[order].items.length; itemIterator++) {


//       let item = {
//         orderNumber: packageData[order].orderNumber.toString().padStart(4, "0"),
//         itemNumber: itemIterator.toString().padStart(5, "0"),
//         productName: packageData[order].items[itemIterator].productName,
//         productImage: packageData[order].items[itemIterator].productImage,
//         height: packageData[order].items[itemIterator].height,
//         length: packageData[order].items[itemIterator].length,
//         width: packageData[order].items[itemIterator].width,
//         weightInLbs: packageData[order].items[itemIterator].weightInLbs,
//         docked : false,
//         position: [
//           LoadXIncrement,
//           LoadYIncrement,
//           LoadZIncrement,
//         ],
//       };
//       //console.log("Item Iterated is " + JSON.stringify(item));
//       items = [...items, item];
//       LoadXIncrement += frameIncrements;
//       if (items.length % maxItemsInRow === 0) {
//         LoadXIncrement = LoadStartX;
//         LoadYIncrement -= frameIncrements;
//       }

//       if (items.length % maxItemsInSide === 0) {
//         LoadXIncrement = LoadStartX;
//         LoadYIncrement = LoadStartY;
//         LoadZIncrement = LoadStartZ * -1;
//       }
//     }
//   }
//   return items;
// }

